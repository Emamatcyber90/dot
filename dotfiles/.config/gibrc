#!/bin/bash

# My rc file, I include this from .profile, .bashrc, and .zshrc like so:
# . "$HOME/.config/gibrc"
# The script must be sourced, only used for syntax highlighting (script can be run with sh).

case $- in
  *i*) [ "$GIBRC" ] && echo "Reusing gibrc..." || echo "Using gibrc..." ;;
  *) return ;; # Exit if not running interactively.
esac

### ENV VAR DEFAULTS ###
export XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-"$HOME/.config"} # Config stuff should go here.
c="$XDG_CONFIG_HOME" # Shortcut to the config directory (`v $c/gibrc` to edit this file).
export XDG_CACHE_HOME=${XDG_CACHE_HOME:-"$HOME/.cache"} # Cache stuff should go here.
export XDG_DATA_HOME=${XDG_DATA_HOME:-"$HOME/.local/share"} # Data should go here.
export LESSHISTFILE=${LESSHISTFILE:-"$XDG_CACHE_HOME/less/history"} # Get less to put its history here.
#export INPUTRC=${INPUTRC:-"$XDG_CONFIG_HOME/inputrc"} # inputrc file goes here (unused currently).
export CARGO_HOME=${CARGO_HOME:-"$XDG_DATA_HOME/cargo"} # Cargo goes here.
export RUSTUP_HOME=${RUSTUP_HOME:-"$XDG_DATA_HOME/rustup"} # Rustup goes here.
export ATOM_HOME=${ATOM_HOME:-"$XDG_CONFIG_HOME/atom"} # Atom goes here.
export HISTFILE=${HISTFILE:-"$XDG_CONFIG_HOME/history"} # Set history file location.
export npm_config_devdir=${npm_config_devdir:-"$XDG_CACHE_HOME/node-gyp"} # Set node-gyp download location.
export npm_cache=${npm_cache:-"$XDG_CACHE_HOME/npm"} # Set npm cache location.
export NODE_REPL_HISTORY=${NODE_REPL_HISTORY="$XDG_CACHE_HOME/node_repl_history"} # Set node-gyp download location.
export BABEL_CACHE_PATH=${NODE_REPL_HISTORY="$XDG_CACHE_HOME/babel/cache.json"} # Set babel cache location.
export CCACHE_DIR="$XDG_DATA_HOME/ccache" # ccache cache dir.
export HELM_HOME="$XDG_DATA_HOME/helm" # Helm home directory.
export BLUEMIX_HOME="$XDG_DATA_HOME/bluemix" # Bluemix home directory (creates .bluemix inside)
export LESS="--tabs=1,3 --ignore-case --RAW-CONTROL-CHARS" # Tab is 2 spaces, search ignores case, enable colours.
[ -d "$XDG_CONFIG_HOME/terminfo" ] && export TERMINFO="$XDG_CONFIG_HOME/terminfo" # Put terminal info in here.

### SHELL SPECIFIC ###
ls --color=auto >/dev/null 2>&1 && alias ls='ls --color=auto' # ls use colour if poss.
[ "$(uname)" = "Darwin" ] && alias ls='ls -G' && alias dl=rmtrash # ls use colour on mac.

if [ "$ZSH_VERSION" ]; then # zsh specific options.
  export ZDOTDIR="${XDG_CONFIG_HOME}/zsh" # Path to zsh config files.
  export ZSH_CUSTOM="${XDG_CONFIG_HOME}/oh-my-zsh" # Path to custom oh-my-zsh config files.
  export ZSH="$XDG_DATA_HOME/oh-my-zsh" # Path to your oh-my-zsh installation.
  ZSH_THEME="gib" # Use my custom theme (in $ZSH_CUSTOM).

  HYPHEN_INSENSITIVE="true" # Use hyphen-insensitive completion.
  DISABLE_AUTO_TITLE="true" # Don't mess with shell title.
  plugins=() # Choose plugins to load.
  fpath+="$XDG_DATA_HOME/zfunc" # Put (or symlink) autocomplete scripts in here.
  fpath+=/usr/local/share/zsh-completions # Homebrew zsh-completions.
  source $ZSH/oh-my-zsh.sh # Load Oh-My-Zsh.
  chpwd() { ls; } # Auto ls after changing directory.
  zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' # Case-insensitive match.
  source "$XDG_DATA_HOME/zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" || true

  # Vim mode and keybindings in zsh:
  autoload -U history-search-end # Not included by default so load (usually /usr/share/zsh/unctions/Zle/).
  zle -N history-beginning-search-backward-end history-search-end # Add it to existing widgets.
  zle -N history-beginning-search-forward-end history-search-end  # Add it to existing widgets.
  accept-line() { [ -z "$BUFFER" ] && zle up-history; zle ".$WIDGET"; }
  zle-keymap-select () { [ $KEYMAP = vicmd ] && printf "\033[2 q" || printf "\033[6 q"; } # Other KEYMAPs are main and viins.
  zle-line-init () { zle -K viins; printf "\033[6 q"; }
  zle -N accept-line # Redefine accept-line to insert last input if empty (Enter key).
  zle -N zle-keymap-select # I-beam cursor in insert mode, block otherwise.
  zle -N zle-line-init     # Part of above cursor hack ^.
  KEYTIMEOUT=10 # Key delay of 0.1s (Esc in vim mode is quicker).

  bindkey -v # Enable vim mode in zsh.

  bindkey -M viins 'kj' vi-cmd-mode # Map kj -> Esc in vim mode.
  bindkey -M viins "^?" backward-delete-char # Make backspace work properly.
  bindkey -M viins "^H" backward-delete-char # <Ctrl>-H = Backspace (Emacs default).
  bindkey -M viins "^W" backward-kill-word # <Ctrl>-W = Delete word (Emacs default).
  bindkey -M viins "^U" backward-kill-line # <Ctrl>-U = Delete line (Emacs default).
  bindkey -M viins "^A" beginning-of-line # <Ctrl>-A = Go to beginning of line (Emacs default).
  bindkey -M viins "^E" end-of-line       # <Ctrl>-E = Go to end of line (Emacs default).
  bindkey -M viins "^R" history-incremental-search-backward # Restore <Ctrl>-R search.
  bindkey -M viins "^S" history-incremental-search-forward  # Restore <Ctrl>-S forward search.
  bindkey -M main "^[[A" history-beginning-search-backward-end # Re-enable up   for history search.
  bindkey -M main "^[[B" history-beginning-search-forward-end  # Re-enable down for history search.

  for i in unalias please po pu rd d afind _ md run-help; do alias | grep -q "$i" && unalias "$i"; done # Doesn't seem to always be defined.
  source "$XDG_DATA_HOME"/fzf/shell/completion.zsh 2> /dev/null
  source "$XDG_DATA_HOME"/fzf/shell/key-bindings.zsh
elif [ "$BASH_VERSION" ]; then # Bash specific options.
  set -o vi # Vim mode in bash.
  shopt -s autocd # type directory name to cd.
  cs() { cd "$@" && ls; } # cs => cd and ls.
  cd=cs # Used in .. commands below (so .. does `cs ..`).
  bind Space:magic-space 2>/dev/null # !31 autoexpands on space.
  bind 'set completion-ignore-case on' 2>/dev/null # case-insensitive tab completion.
  PS1=' \[\e[32;1m\]\w $ \[\e[0m\]'
  source "$XDG_DATA_HOME"/fzf/shell/completion.bash 2> /dev/null
  source "$XDG_DATA_HOME"/fzf/shell/key-bindings.bash
fi


### FUNCTIONS ###
md() { mkdir -p $*; [ $# = 1 ] && cd "$1" || true; } # md foo = mkdir foo && cd foo.
exists() { type "$1" >/dev/null 2>&1; } # Check if command exists (is in path).
# Add to beginning of path.
pathadd() { [ -d "$1" ] && export PATH="$1"$(echo ":$PATH:" | sed "s|:$1:|:|" | sed 's|:$||'); }
# Add to end of path.
pathapp() { [ -d "$1" ] && export PATH=$(echo ":$PATH:" | sed "s|:$1:|:|" | sed 's|^:||')"$1"; }
exists fd || fd() { find . -iname "*$**"; } # Find by filename (case insensitive).
pth() { # Returns absolute path to file(s) including file name.
  for i in "$@"; do # Args = relative filenames.
    if [ -d "$i" ]; then (pushd "$i" >/dev/null; pwd) # dir.
    elif [ -f "$i" ]; then  # file.
      if [[ $i == */* ]]; then echo "$(pushd ${i%/*} >/dev/null; pwd)/${i##*/}"
      else echo "$(pwd)/$i"; fi; fi
  done
}

### ALIASES ###
alias x=exit # x exits the terminal.
alias c=clear # c clears the terminal screen (can also use Ctrl-L).
alias g=git # Use with commands in $c/git/config for best results.
alias path='echo $PATH' # Single quotes so we echo path at runtime, not alias time.
alias h=history # Shows command history.
alias s='printf "\033[2 q" && ssh' # Reset cursor to block and ssh.
alias dt="date +%Y-%m-%d" # Basic date format (unambiguous, easy to sort etc.)
alias dT="date +%d-%b-%y" # More readable date format (ambiguous).
alias cal='cal | grep --color -EC6 "\b$(date +%e | sed "s/ //g")"' # More readable date format (ambiguous).
scpkey() { ssh $1 'mkdir -p ~/.ssh'; scp ~/.ssh/${2:-authorized_keys_scp} $1:~/.ssh/authorized_keys; } # scp key to host.

alias l='ls -lAh' # Hidden, detail, human readable numbers.
alias la='ls -A'  # List hidden files as well.
alias ll='ls -l'  # Gives more detail about files.
[ -z "$cd" ] && cd=cd # We only want cd=cs in bash.
alias ..="$cd .."             # .. -> go up a directory.
alias ...="$cd ../.."             # ↳ go up two directories.
alias ....="$cd ../../.."         # ↳ go up two directories.
alias .....="$cd ../../../.."     # ↳ go up two directories.
alias ......="$cd ../../../../.." # ↳ go up two directories.
alias -- -="$cd -" # - cd's to the last directory.
# Execute previous commands (1 = !-2, 2 = !-3 etc., remember that Enter is !!)
alias 1="fc -e : -2"; alias 2="fc -e : -3"

{ exists nvim && VIM=nvim; } || { exists vim && VIM=vim; } || VIM=vi # Take what you can get.
export VISUAL=${VISUAL:-$VIM} EDITOR=${EDITOR:-$VIM} # Set vim/nvim as the default editor.
if [ "$ZSH_VERSION" ]; then
  alias xv='xargs $=VISUAL' v='$=VISUAL' # Work around zsh's "helpful" autoquoting.
else
  alias xv='xargs $VISUAL' v='$VISUAL'
fi
exists vimr && alias vm=vimr # Use `vm` for GUI vim, need to add a Linux equivalent.
ulimit -c unlimited # Allow saving of coredumps.
alias busy='cat /dev/urandom | hexdump -C | grep "ca fe"' # Makes it look like you're busy with important hacker stuff.
[ $(uname) = "Darwin" ] && alias ldd="otool -L" # macOS equivalent to ldd.
[ $(uname) = "Darwin" ] && { alias cpy="pbcopy"; alias pst="pbpaste"; alias o=open; } # Cross-platform copy/paste/open terminal commands.
[ $(uname) = "Linux" ] && { alias cpy="xclip -selection clipboard"; alias pst="xclip -selection clipboard -o"; alias o=xdg-open; }

### APP SPECIFIC ###
pathadd "$HOME/bin" # Put random binaries you want to run in here.
pathadd /usr/lib/ccache # Add ccache to the path if installed (Linux).
pathadd /usr/local/opt/ccache/libexec # Add ccache to the path if installed (macOS).
pathadd "$HOME/.local/bin"
pathapp /usr/local/opt/coreutils/libexec/gnubin # Coreutils from brew on macOS, don't replace mac ls.

# I don't have nvm autorun on every shell, I us `nv` when I want to start it.
# This also allows me to frequently `make -j4 install` node master, and have
# that as the default (in /usr/local/bin/node).
export npm_config_userconfig="$XDG_CONFIG_HOME/npm/config"
export NVM_DIR="$XDG_DATA_HOME/nvm" # Use nvm.
alias nv='. $NVM_DIR/nvm.sh'  # Start nvm with alias, o/w too much startup cost.

## Rust commands.
alias cn="cargo new --bin"; alias cl="cargo clippy"
alias cb="cargo build"; alias cr="cargo run"; alias ct="cargo test"
alias ctag='ctags -R . $HOME/bin/src/rust' # Populate ctags from rust src.
alias ru=rustup; pathadd "$CARGO_HOME/bin"
alias e=exercism
alias k=kubectl
rs() { for i in $@; do rustc ${i%.rs}.rs; ./${i%.rs}; done; } # Compile/run (rs a.rs b).
exists fd && export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git' # Use fd for fuzzy finding if available.

# Build node with ninja.
alias bn='export CPPFLAGS=-fdiagnostics-color && ./configure && tools/gyp_node.py -f ninja && ninja -C out/Release && ln -fs out/Release/node node'

### SSH PROMPT ###
alias bashme="PS1='\[\e[35;1m\]\h \n \w $ \[\e[0m\]'" # Manually set bash prompt.
## Set prompt for SSH windows.
if [ "$SSH_CLIENT" -o "$SSH_TTY" ]; then
  if [ "$ZSH_VERSION" ]; then
    : # Do nothing, this is covered in the gib theme in $ZSH_CUSTOM.
  elif [ "$BASH_VERSION" ]; then # assume Bash ## Shell basics.
    PS1='\[\e[35;1m\]\h \n \w $ \[\e[0m\]'
  else
    myshell=dash
    myshell=${myshell:-"$(ls -l /proc/$$/exe | sed 's%.*/%%')"}
    case $0 in
      -ksh) myshell=ksh;;
      -sh) myshell=dash;;
    esac
    if [ "$myshell" = "ksh93" ]; then
      PS1='\E[35;1m '"$(hostname)"' \n $PWD \E[0m $ '
    else
      PS1="$(uname -n)"' $PWD $ '
    fi
  fi
else # Things to only do if we're not in SSH mode.
  # Set key repeat rate if available (Linux only). You probably want something
  # less insane here, like rate 250 30. If you remove the line below, you also
  # need to remove the else above (or replace below line with a single : ).
  if [ "$(uname)" = Linux ]; then
    exists xset && xset r rate 120 45
    export PANEL_FIFO="/tmp/panel-fifo" # Used by bspwm.
  fi
fi

# Basic keys on old shells.
if [ "$myshell" = "ksh93" -o "$myshell" = "ksh" ]; then
  set -o emacs
  alias __A=`echo "\020"`     # up arrow = ^p = back a command.
  alias __B=`echo "\016"`     # down arrow = ^n = down a command.
  alias __C=`echo "\006"`     # right arrow = ^f = forward a character.
  alias __D=`echo "\002"`     # left arrow = ^b = back a character.
  alias __H=`echo "\001"`     # home = ^a = start of line.
  alias __Y=`echo "\6"`       # end = ^e = end of line.
fi

export GIBRC=true # Use this to check for things that should only run once.
